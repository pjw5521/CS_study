## Hash Table 

#### 작성자 : [박지원](@pjw5521)

</br>

## **1. Hash Table 이란 ?**
- (key, value)로 데이터를 저장하는 자료구조 
- 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 가진다.
- 각각의 key 값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색한다.
- key값으로 데이터를 찾을 때 해시 함수를 1번만 사용하면 되므로 평균 시간 복잡도는 O(1)이다. 매우 빠르게 데이터를 저장, 삭제, 조회할 수 있다. 


## **2. Hash Function(Hash Method)**
- key을 고유한 인덱스 값으로 설정할 때 사용되는 알고리즘 
- hashcode : 이 메소드에 의해 반환된 데이터의 고유한 숫자 값
- Hash Function을 통해 동일한 값이 도출될 수 있다. 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 **Collision**이 발생할 수 있다.
- Collision : 서로 다른 두 개의 키가 같은 인덱스로 해싱되는 것 

## **3. Collision 해결 방법 **
- Hash Fuction은 Collision을 최소화하는 방향으로 설계하고, 발생하는 Collision에 대비해야 한다. 
- 1:1 대응이 되도록 만들면 array와 다를 바가 없고 메모리를 많이 차지하게 된다. 
- Collision이 많아질수록 시간 복잡도가 O(n)에 가까워진다. 

### **Open Address 방식 (개방주소법)**
- 해시 충돌이 발생하면, 다른 해시 버켓에 해당 자료를 삽입하는 방식 
- 다른 해시 버킷을 찾는 방법 
    - Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행
    - Quadratic Probing : 2차 함수를 이용해 탐색할 위치를 찾는 방식 
    - Double hasing Probing : 하나의 해시 함수에서 충돌이 발생하면 2차 해시 함수를 이용해 새로운 주소를 할당하는 방식. 위 두가지 방법에 비해 많은 연산
- Worst Case의 경우, 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 

### **Separate Chaining 방식(분리 연결법)**
- Open Address 방식의 경우 해시 버킷을 채운 밀도가 높아질 수록 Worst case 발생 빈도가 높아진다. Separate Chaining 방식의 경우 보조 해시 함수를 통해 조정한다. 
- 연결 리스트 사용하는 방식 
    - 버킷들을 연결리스트로 만들어 Collision이 발생하면 해당 버킷의 리스트에 추가하는 방식 
    - 삽입, 삭제 간단
    - 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드 부담 
    - 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블 확장을 늦출 수 있다. 
- Tree 사용하는 방식
    - 트리는 기본적으로 메모리 사용량이 많기 때문에, key-value 쌍의 개수가 적을 때는 연결 리스트를 사용
- 보조 해시 함수 함께 사용 

### **비교**
- 두 방식 모두 Worst Case에서 O(M)
- Open Address 방식은 연속된 공간에 데이터를 저장하기 때문에 캐시 효율이 높다. 
- Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있다. 

### **해시 버킷 동적 확장(Resize)**
- key-value 쌍의 개수가 일정 개수 이상되면 해시 버킷의 개수를 두 배로 늘린다. 
- 임계점은 현재 데이터의 개수가 해시 버킷의 개수의 75%(load factor)가 될 때이다. 