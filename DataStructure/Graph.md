## Graph

#### 작성자 : [박지원](@pjw5521)

</br>

## **1. Graph **
- 정점과 간선의 집합 
- Undirected Graph : 방향성이 없는 그래프
- Directed Graph : 간선에 방향성이 포함된 그래프
- Degree : Undirected Graph에서 정점에 연결된 Edge의 개수  
    - Outdegree : 정점으로부터 나가는 간선의 개수 
    - Indegree : 정점으로 들어오는 간선의 개수 
- Wieght Graph : 간선에 가중치를 두어서 구성한 그래프 
- Sub Graph : 본래 그래프의 일부 정점 및 간선으로 이루어진 그래프 

## **2. 그래프 구현 방법**
### 인접 행렬 (adjacent matrix)
    - 정방 행렬 사용 
    - 위치의 value 값으로 정점 간 연결관계를 O(1)로 파악 가능 
    - Dense Graph 표현 시 적절 

### 인접 리스트 (adjacent list)
    - 연결 리스트 사용 
    - 정점 간 연결 관계를 확인하는데 오래 걸김
    - Sparse graph 표현 시 적절 

## **3. 그래프 탐색**
### 깊이 우선 탐색 (Depth First Search : DFS)
- 임의의 한 정점으로부터 연결되어있는 한 정점으로만 나아간다.
- 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는 지 살펴본다.
- Stack 사용 
- 시간 복잡도 : O(V+E)

### 너비 우선 탐색 (Breadth First Search : BFS)
- 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다.
- 나아갈 정점의 순서를 기록하기 위해 Queue 사용 
- 시간 복잡도 : O(V+E)


## **4. Minimum Spanning Tree(최소 비용 신장 트리, MST)**
- 가중치의 합이 최소인 spanning tree 
- 신장 부분 그래프 (Spanning Tree) : 그래프의 모든 정점이 사이클없이 연결된 부분 그래프 
- n개의 정점을 갖는 그래프에서 신장 트리에 속하는 간선의 개수는 n-1개이고, 사이클이 발생하면 안된다. 
- 크루스칼 알고리즘(Kruskal Algorithm)과 프림 알고리즘(Prim Algorithm)으로 구할 수 있다. 

### 크루스칼 알고리즘 
- 모든 노드를 최대한 적은 비용으로 **연결만**시키면 되므로 모든 간선 정보를 오름차순으로 정렬한 뒤에 비용이 적은 간선부터 그래프에 포함시키는 방식 
- 동작 방식 
    1. 모든 간선들을 가중치를 기준으로 오름차순 정렬한다. 
    2. 정렬된 순서에 맞게 그래프에 포함시킨다.
    3. 포함 시키기 전에 사이클이 형성됐는지 확인한다. (Union-find 알고리즘 사용)
    4. 사이클을 형성하는 경우 간선을 포함하지 않는다. 
- 사실 상 정렬 알고리즘과 Union-find 알고리즘을 합친 것이고, Union-find 알고리즘의  시간복잡도는 O(1)이므로 정렬 알고리즘의 시간 복잡도와 동일하다고 판단해도 무리가 없다. 

## 프림 알고리즘
- 임의의 시작점에서 현재까지 연결된 정점들에서 연결되지 않은 정점들에 대해, 가장 가중치가 적은 정점을 연결하는 방식
- 트리를 단계적으로 확장
- 우선순위 큐를 이용한 최소 힙으로 구현할 수 있고, 다익스트라 알고리즘과 구현 방식이 유사하다.
- 동작 방식 
    1. 임의의 정점을 시작점으로 선택한다.
    2. 시작점에서 갈 수 있는 정점 중 가장 가중치가 작은 정점을 연결한다.
    3. 2번에서 시작점과 연결된 정점들의 집합을 A 집합이라 할 때, A 집합에서 갈 수 있는 A 집합에 속하지 않은 정점들에 대해 가중치가 가장 작은 정점을 연결한다.
    4. 위 과정을 모든 정점이 연결될 때까지 반복한다. 