## 비트마스크 (BitMask)

---

- 집합의 요소들의 구성 여부를 표현할 때 유용한 테크닉

### **왜 비트마스크를 사용하는가?**

- DP나 순열 등, 배열 활용만으로 해결할 수 없는 문제
- 작은 메모리와 빠른 수행시간으로 해결이 가능 (But, 원소의 수가 많지 않아야 함)
- 집합을 배열의 인덱스로 표현할 수 있음
- 코드가 간결해짐

**비트(Bit)란?**

- 컴퓨터에서 사용되는 데이터의 최소 단위 (0과 1) 2진법을 생각하면 편하다.

비트 연산

- AND(&) : 대응하는 두 비트가 모두 1일 때, 1 반환
- OR(|) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일때, 1 반환
- XOR(^) : 대응하는 두 비트가 서로 다를 때, 1 반환
- NOT(~) : 비트 값 반전하여 반환
- SHIFT(>>, <<) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환

### **1. 삽입**

현재 이진수로 `10101`로 표현되고 있을 때, i번째 비트 값을 1로 변경하려고 한다.

i = 3일 때 변경 후에는 `11101`이 나와야 한다. 이때는 **OR연산을 활용**한다.

```python
10101 | 1 << 3
```

`1 << 3`은 `1000`이므로 `10101 | 01000`이 되어 `11101`을 만들 수 있다.

### **2. 삭제**

반대로 0으로 변경하려면, **AND연산과 NOT 연산을 활용**한다.

```python
11101 & ~1 << 3
```

`~1 << 3`은 `10111`이므로, `11101 & 10111`이 되어 `10101`을 만들 수 있다.

### **3. 조회**

i번째 비트가 무슨 값인지 알려면, **AND연산을 활용**한다.

```python
10101 & 1 << i
```

3번째 비트 값 : 10101 & (1 << 3) = 10101 & 01000 → 0
4번째 비트 값 : 10101 & (1 << 4) = 10101 & 10000 → 10000

이처럼 결과값이 0이 나왔을 때는 i번째 비트 값이 0인 것을 파악할 수 있다. (반대로 0이 아니면 무조건 1인 것)

이러한 방법을 활용하여 문제를 해결하는 것이 비트마스크다.
