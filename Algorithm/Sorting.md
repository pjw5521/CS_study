# 정렬 알고리즘

</br>

## Sorting

정렬 알고리즘(Sorting)은 n개의 숫자가 입력으로 주어졌을때, 이를 사용자가 지정한 기준(오름차순, 내림차순)에 맞게 정렬하는 알고리즘이다. 이 정렬 알고리즘의 핵심은 얼마나 효율적으로 수행할 수 있느냐 이다.

</br>


## 수행시간 O(N^2)
- 계산시간이 정렬할 자료의 수에 제곱에 비례해서 늘어나는 정렬 알고리즘으로 대표적으로 거품정렬, 선택정렬, 삽입정렬이 있다.

</br>

### 거품 정렬(Bubble sort)

#### 방법
- 서로 인접한 두 원소의 대소르 비교하고, 조건에 맞지 않는다면 자리를 교환하며 정렬하는 알고리즘이다. 
- 1번 회전식 n번째오 n+1번재 원소를 계속해서 비교해가며 자리르 바꿔주면 맨 마지막 원소가 가장 큰 값이기 때문에 다음 회전에서는 제외된다.

#### 그림
<img width="653" alt="스크린샷 2022-05-22 오후 8 56 33" src="https://user-images.githubusercontent.com/60414900/169693990-5ba8dbd2-2d33-4632-a56a-3f585a50f38e.png">


#### 시간 및 공간 복잡도
- 시간복잡도: O(n^2)
- 공간복잡도: O(n)

</br>

### 선택정렬(Selection sort)  
<img width="662" alt="스크린샷 2022-05-22 오후 8 56 50" src="https://user-images.githubusercontent.com/60414900/169693999-6e9951d8-d0ae-41d0-80e0-5878122dd565.png">

#### 방법
- 조건(오름차순, 내림차순)에 따라 최소(혹은 최대)값의 index를 갱신하며 찾는다. 그리고 찾은 인덱스를 조건에 맞느 index의값과 교환한다.
- 조건에 해당에 따라 오름차순이라면 교환이 일어나서 위치가 바뀐 값을 제외하고 다시 시작한다.

#### 그림


#### 시간 및 공간 복잡도
- 시간복잡도: O(n^2)
- 공간복잡도: O(n^2)

</br>

### 삽입정렬(Insertion sort) 

#### 방법
- 두번째 index의 값부터 temp라는 임시변수의 저장하며 시작한다.
- temp와 원소들을 차례대로 비교해가며 삽입할 위치를 찾는다.
- 다음 값으 temp에 저장하고 다시 위 프로세스를 반복한다.

#### 그림
<img width="654" alt="스크린샷 2022-05-22 오후 8 57 05" src="https://user-images.githubusercontent.com/60414900/169694007-d69a5ae3-e83a-4618-8eb8-e4bc048c3619.png">

#### 시간 및 공간 복잡도
- 시간복잡도: O(n^2)
- 공간복잡도: O(n^2)
- 최선의 경우 시간복잡도가 O(n)이기 때문에, 다른 정렬 알고리즘의 사용될 경우도 있는 좋은 알고리즘이다. 


</br>

## 수행시간 O(nLOGn)
- 계산시간이 정렬할 자료의 수에 NlogN에 비례해서 늘어나는 정렬 알고리즘, 일반적으로 최악의 상황에도 nLOGn 을 유지하지만 퀵정렬의 경우는 최악의 순간 N^2 만큼 걸린다. 하지만 실제로 일반적인 상황에서는 퀵정렬이 가장 빠르기 때문에 퀵 정렬을 조그 개량하여 최악의 경우가 발생하지 않도록 코드를 작성한다.

</br>

### 병합/합병 정렬 (Merge sort)  

#### 방법
- 분할 정복 방법을 통해 구현한 정렬 방법이다.
- 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
- 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
- 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
- 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

#### 그림
![스크린샷 2022-05-22 오후 8 34 05](https://user-images.githubusercontent.com/60414900/169693116-1b61b1f6-acdf-4b39-875d-d09ad3b09c1c.png)

#### 시간 및 공간 복잡도
- 시간복잡도: 평균, 최선, 최악 모두 O(NlogN)
- 공간복잡도: O(NlogN)

</br>

### 퀵 정렬(Quick sort)  

#### 방법
- 분할 정복 방법을 통해 구현한 정렬 방법이다.
- 배열 가운데서 하나의 원소를 고릅니다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다,
- 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
- 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.
- 재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

#### 그림
<img width="526" alt="스크린샷 2022-05-22 오후 8 57 50" src="https://user-images.githubusercontent.com/60414900/169694044-6fdeb235-2261-4386-88c4-f9b1291ed1f1.png">

#### 시간 및 공간 복잡도
- 시간복잡도: 평균, 최선의 경우 O(NlogN) 이지만 최악의 경우 O(N^2)이다.
- 공간복잡도: O(NlogN)

</br>

### 힙 정렬(Heap sort)  

#### 방법
- 완전 이진 트리의 일종으로 우선순위 큐를 위하야 만들어진 heap을 이용한 정렬 방법이다.
- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법이다.
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정 설명
  - 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
  - 내림차순을 기준으로 정렬
- 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
- 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.

#### 그림
![스크린샷 2022-05-23 오후 6 22 34](https://user-images.githubusercontent.com/60414900/169787761-c37986db-2fbc-441c-af53-008c1c14a273.png)

예시 
![스크린샷 2022-05-23 오후 6 21 54](https://user-images.githubusercontent.com/60414900/169787634-85ce00e9-6d65-451b-b417-381be4ac292c.png)


#### 시간 및 공간 복잡도
- 시간복잡도: O(NlogN)
- 공간복잡도: O(NlogN)

</br>

### 기수 정렬(Radix sort)  

#### 방법
- 기수 정렬은 배열에 원소들이 있을 때, 각각의 자리수 별로 정렬하여 완벽히 정렬된 배열을 만들어 내는 알고리즘이다.



#### 그림
![스크린샷 2022-05-23 오후 6 32 50](https://user-images.githubusercontent.com/60414900/169789794-7b5b9b88-4cce-4ba1-b557-f35734d264c9.png)


#### 시간 및 공간 복잡도
- 시간복잡도: O(N)
- 공간복잡도: O(N*K(최대 자릿수))

</br>

### 계수 정렬(Counting sort)  

#### 방법
- 중복된 숫자가 많은 정렬일때 효과적이다.
- 제약사항이 존재한다.
  - 데이터 값은 항상 양수여야 한다.
  - 값의 범위가 메모리 사이즈를 넘어가선 안된다. 
  - 그 이유는 배열의 인덱스를 이용하여 데이터를 저장하기 때문이다.
- 계수 정렬(counting sort)는 정렬되지 않은 배열의 수들이 몇 번 나왔는지 기억한다.
- 몇 번 나왔는 지 기록한 배열을 count 배열이라고 할대, count 배열을 앞부터 순회하여, 자신이 정렬된 배열에서 몇 번째에 나와야 하는 지 기록한다.
- 정렬된 배열에서 자신이 몇 번째에 나와야하는 지 기록한 배열을 sum 배열이라 하자, sum 배열의 맨 마지막 값부터 순회하여, 정렬 배열에 값을 쓴다.
- 값을 쓸 때, count배열과 sum배열의 값을 하나씩 줄이고 0 될 때 까지 반복한다.

#### 그림

예시   
![스크린샷 2022-05-23 오후 6 28 26](https://user-images.githubusercontent.com/60414900/169788925-3cde8e20-5634-46ab-ac0f-87974f666077.png)

풀이  
![스크린샷 2022-05-23 오후 6 30 56](https://user-images.githubusercontent.com/60414900/169789399-552648f7-03b7-4b48-a041-de0f35a05a58.png)

![스크린샷 2022-05-23 오후 6 30 30](https://user-images.githubusercontent.com/60414900/169789319-01b08d2f-41c4-49b2-b366-65786741d541.png)


#### 시간 및 공간 복잡도
- 시간복잡도: O(N)
- 공간복잡도: O(N+k)







