# TCP 3 way-Handshake & 4 way-Handshake

TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish)하는 과정

클라이언트와 서버가 통신을 하기 전 정확한 전송을 보장하기 위해 컴퓨터간 세션을 수립하는 과정으로써, TCP 프로토콜에서 신뢰성을 보장하기 위해 사용된다.

**참고)** 

**TCP**는 연결지향적인 특성과 자체적으로 오류를 처리하며 순서가 뒤바뀐 패킷을 교정해주는 기능이 더불어 주로 데이터의 **신뢰도**가 중요하다고 판단되어질 때 쓰인다.
**신뢰도 확보**가 중요하거나 용량이 큰 데이터를 전달해야 때, 실시간일 필요는 없을 때 활용 된다.
만약 데이터의 신뢰성보다 전송 속도가 중요시 되는 경우에는 UDP 방식을 사용한다.

## TCP 3 way-Handshake 역할

- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작되기 전에 한쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
- 양쪽 모두 상대편에 대한 초기 순차일련번호를 얻을 수 있도록 한다.

## TCP 3 way-Handshake 과정

### 연결 성립 (Connection Establishment)

![https://media.vlpt.us/images/deannn/post/e40780ae-8e60-439f-9ed2-072ed978e91b/image.png](https://media.vlpt.us/images/deannn/post/e40780ae-8e60-439f-9ed2-072ed978e91b/image.png)

1. 클라이언트는 서버에 접속을 요청하는 **SYN(a)** 패킷을 보낸다. 
    - 이 때, 클라이언트는 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다.
2. 서버는 클라이언트의 요청인 **SYN(a)**을 받고 클라이언트에게 요청을 수락한다는 **ACK(a+1)**와 **SYN(b)**이 설정된 패킷을 발송한다. 
    - 이 때, 서버는 SYN_RECEIVED 상태가 된다.
3. 클라이언트는 서버의 수락 응답인 **ACK(a+1)**와 **SYN(b)** 패킷을 받고 **ACK(b+1)**를 서버로 보내면 연결이 성립(establish)된다.
    1. 이 때, 서버는 ESTABLISHED 상태가 된다.
    

## TCP 4 way-Handshake 과정

### 연결 해제 (Connection Termination)

![https://media.vlpt.us/images/deannn/post/37483cd2-f01f-48ba-91ea-da7abf9c3920/image.png](https://media.vlpt.us/images/deannn/post/37483cd2-f01f-48ba-91ea-da7abf9c3920/image.png)

1. 클라이언트가 연결을 종료하겠다는 **FIN플래그**를 전송한다.
2. 서버는 클라이언트의 요청(**FIN**)을 받고 알겠다는 확인 메세지로 **ACK**를 보낸다.2-1. 그리고 나서 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.
3. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 **FIN 플래그**를 전송한다.
4. 클라이언트는 **FIN 플래그**를 확인했다는 메세지(ACK)를 보낸다.
5. 클라이언트의 **ACK 메세지**를 받은 서버는 **소켓 연결을 close**한다.
6. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (**TIME_WAIT)

### SYN? ACK?

> SYN(SYnchronize sequence Numbers) : 상대의 통신 응답을 나타냄
ACK(ACKnowledgment) : 상대에 대한 접속 요청을 나타냄
> 

**TCP Header**에는 **Code Bit(Flag bit)**라는 부분이 존재한다. 
이 부분은 총 6Bit로 이루어져 있으며 각각 하나의 bit마다 의미를 갖고 있다. 
**Urg-Ack-Psh-Rst-Syn-Fin** 순서로 되어있으며, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다. 예를 들면 SYN 패킷의 경우에는 000010이 되고 ACK 패킷의 경우에는 010000이 된다.

+) FIN : 접속 종료를 나타냄

### 두 종류의 패킷을 사용하는 이유

연결을 성립하기 위해서는 서로 통신이 가능한지 파악해야 한다. 이를 위해 패킷을 먼저 주고 받아야 한다. 하지만 굳이 두 종류의 패킷을 사용하는 이유는 **요청**과 **응답**에 대한 패킷을 주고 받아야 하기 때문이다.

### 2way가 아닌 3way인 이유

**⇒ 클라이언트가 서버에게 패킷을 보내 통신이 가능한지 확인하는 것과 별개로 그 반대인 서버가 클라이언트에게 패킷을 보내 클라이언트가 잘 수신하는지 확인할 필요가 있기 때문**

비유를 들어보자. 클라이언트가 서버에게 자신의 목소리가 들리는지 물어본다 (SYN)서버는 클라이언트의 목소리가 들린다고 말한다.(SYN+1) 그리고 자신의 목소리가 들리는지 물어본다.(ACK)클라이언트는 서버의 목소리가 잘 들린다고 말한다.(ACK+1)

TCP connection은 양방향성(bidirectional) connection이다. 클라이언트에서 서버에게 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, 서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. 그렇기 때문에 2-way-handshake로는 부족하다.

위와 같은 과정으로 서로 통신이 가능한지 확인한다.

### sequence number가 난수인 이유

**⇒ 포트가 재사용될 가능성이 있으므로 이전 connection과 구분해 오류를 줄이기 위해서**

처음 클라이언트에서 SYN 패킷을 보낼 때 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 Sequence Number를 **ISN**이라고 한다. ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇인가? **Connection을 맺을 때 사용하는 포트(port)**는 **유한 범위 내에서 사용하고 시간이 지남에 따라 재사용**된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 보고 패킷을 구분하게 되는데, 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제를 발생할 가능성을 줄이기 위해 난수로 ISN을 설정한다.
