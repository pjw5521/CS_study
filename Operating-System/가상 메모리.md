# 가상 메모리

- 물리 메모리 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술
- 가상 메모리를 이용하면 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있음
- 가상 메모리의 구성
    - 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역
    - 가상 메모리에서 물리 메모리의 부족한 부분을 스왑 영역으로 보충
- 가상 메모리의 기본 아이디어
    - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 바꿔주면 됨
        - virtual address(가상 주소) : 프로세스가 참조하는 주소
        - physical address(물리 주소) : 실제 메모리 주소
    - MMU (Memory Management Unit) : CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

---

## 요구 페이징 (demand paging)

- 선행 페이징(prepaging)과 반대 개념
    - 선행 페이징 : 미리 프로세스와 관련된 모든 데이터를 메모리에 올려놓고 실행하는 방식
- CPU가 해당 페이지를 요구할 때까지 그 페이지를 메모리에 올리지 않는 방식 (즉, 한번도 접근되지 않는 페이지는 물리 메모리에 전혀 적재되지 않음)
- 프로세스 내의 개별 페이지들은 “페이저"에 의해 관리. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어와서 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있음
- 장점 : CPU 이용률과 처리율이 높아짐. 더 많은 사용자 수용 가능.
- 페이지 부재(page fault)가 발생하면 그 때 트랩을 걸어 해당 페이지를 적재
- 페이지 부재 : 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황

## ****Page fault trap(페이지 부재 트랩)****

- 페이지 교체
    - 페이지 부재가 발생하면 스왑 영역의 페이지를 메모리의 빈 영역에 올리고 페이지 테이블 업데이트
    - 빈 프레임이 없을 때는 메모리에 있는 프레임 중 하나를 스왑 영역으로 내보낸 후에 해당 페이지를 가져올 수 있음

---

## 페이지 교체 알고리즘

- 페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이지 부재) 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법

1. **FIFO** - First In First Out
    1. 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
    2. 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있음
    3. `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재
    
2. **OPT** - ****최적 페이지 교체(Optimal Page Replacement)****
    1. 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체
    2. 주로 비교 연구 목적으로 사용
    3. 장점 : 알고리즘 중 가장 낮은 페이지 부재율을 보장
    4. 단점 : 구현이 어려움. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없음****
    
3. **LRU** - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
    1. 가정 : 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다
    2. 시간 지역성 성질 고려함 (최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질)
    3. 사용된 시간을 알수있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거 (페이지마다 카운터 필요)
    4. 큐로 구현가능. 사용한 데이터를 큐에서 제거하여 맨 위로 다시 올리고, 프레임이 모자랄 경우 맨 아래에 있는 데이터를 삭제
    5. 단점: 프로세스가 주기억장치에 접근할때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생. 카운터나 큐, 스택과 같은 별도의 하드웨어가 필요
    6. *카운터 : 각 페이지별로 존재하는 논리적인 시계(Logical Clock)로, 해당 페이지가 사용될때마다 0으로 클리어 시킨 후 시간을 증가시켜 시간이 가장 오래된 페이지를 교체*
    
4. **LFU** - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체
    1. 참조 횟수가 가장 적은 페이지를 교체하는 방법. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘.
    2. 특징
        - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있음
        - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않음
        - LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조횟수를 통해 장기적 시간규모에서의 참조성향 고려할 수 있음
        - 단점 : 가장 최근에 불러온 페이지가 교체될 수 있음, 구현 더 복잡, 막대한 오버헤드
        
5. **MFU** - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
    1. 가정 : 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이다
    2. 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않음
    
6. **NUR** - Not Used Recently : 최근에 사용하지 않은 페이지 교체 (클럭 알고리즘)
    1. 최근에 사용하지 않은 페이지 교체 (LRU를 근사한 알고리즘)
    2. 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 못함
    3. 적은 오버헤드로 적절한 성능
    4. 동일 그룹 내에서 선택 무작위
    5. 각 페이지마다 두개의 비트 `참조 비트(Reference Bit)`와 `변형 비트(Modified Bit, Birty Bit)`가 사용됨
        1. 참조 비트: 페이지가 참조되지 않았을 때 0, 호출되었을 때 1 (모든 참조비트를 주기적으로 0으로 변경)
        2. 변형 비트: 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때 1
        3. 우선순위: 참조비트 > 변형비트
        

**스레싱(Thrashing)**

- 반복적으로 페이지 폴트가 발생해서 과도한 페이지 교체 작업이 일어나 실제로는 아무 일도 하지 못하는 상황
- 프로그램은 수행하지 못한 채 페이지 폴트와 페이지 스왑만 반복적으로 수행
