# 메모리 관리 전략

---
### 면접 질문 예시/답변
- **운영 체제에서 페이징을 사용하는 것은 무엇입니까?**
    
    페이징은 운영 체제에서 외부 단편화 문제를 해결하는 데 사용된다. 이 기술을 사용하면 필요한 데이터를 최대한 빨리 사용할 수 있다.
    
- **가상 메모리(Virtual Memory)란 무엇입니까?**
    - 가상 메모리는 프로세스가 메모리 외부에서 실행될 수 있도록하는 매우 유용한 메모리 관리 기술이다. 이 기술은 실행 프로그램이 실제 메모리보다 클 때 특히 사용된다.
- 페이징의 장점과 단점은?
    - 장점: 메모리를 페이지단위로 가져와서, 프로세스의 효율적인 운영이 가능하다.
    - 단점: 페이지 크기별, 단위별로 페이지 폴트 현상이 발생할 수 있다.
- 세그먼테이션(Segmentation)이란?
    - 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(segment)로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다. 미리 분할하는 것이 아니라 메모리를 사용할 시점에 할당된다. 내부단편화는 없지만 외부단편화가 발생할 수 있다.
- 메모리 단편화란 무엇인가?
    - 메모리의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상을 말한다. 할당한 메모리를 해제를 하게 되면 그 메모리 공간이 빈 공간(사용하지 않는 공간)이 되고 그 빈 공간의 크기보다 큰 메모리는 사용할 수 없다. 그리하여 이 공간들이 하나 둘 쌓이게 되면 수치상으로는 많은 메모리 공간이 남았음에도 불구하고, 실제로 사용할 수 없는 메모리가 발생한다.
- 내부 단편화와 내부 단편화란?
    - 내부 단편화
        
        : 분할된 영역이 할당된 프로그램의 크기보다 커서 사용되지 않고 남아 있는 빈 공간을 말한다. 내부 단편화는 페이징에서 발생한다.
        
    - 외부 단편화
        
        : 분할된 영역이 할당될 프로그램의 크기보다 작아서 모두 빈 공간으로 남아 있는 전체 영역을 말한다. 외부 단편화는 세그먼테이션에서 발생한다.
        
- 메모리 단편화 해결방법은?
    - 메모리 압축(디스크 조각 모음), 메모리 통합(단편화가 발생된 공간들을 하나로 통합시켜 큰 공간으로 만드는 기법)

- - -



## 단일 프로그래밍 환경에서의 메모리 할당

- 메모리 오버레이 : 프로그램 크기가 물리 메모리보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
    - 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에서 가져와 사용
    - 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능 ⇒ 가상 메모리 시스템의 기본 개념
- 스왑(swap)
    - 메모리에 필요한 모듈을 가져오기 위해 기존 모듈을 하드디스크의 “스왑 영역(swap area)"에 보관
    - 스왑인(swap in, 스왑 영역 → 메모리), 스왑아웃(swap out, 메모리 → 스왑 영역)
    - 실제 메모리 크기 + 스왑 영역 크기 ⇒ 전체 메모리로 인식 (사용자 입장에서 실제 메모리 크기에 관계없이 큰 프로그램 실행 가능)

<br/>

## 다중 프로그래밍 환경에서의 메모리 할당

- 메모리 분할 방식
    - 가변 분할 방식
        - 프로세스 크기에 맞게 메모리 분할
        - 메모리의 영역이 각각 다름
        - 연속 메모리 할당
        - 장점 : 프로세스를 연속된 공간에 배치
        - 단점 : 비어 있는 공간을 하나로 합쳐야 하며, 이 과정에서 다른 프로세스의 자리도 옮겨야 하므로 메모리 관리 복잡
    - 고정 분할 방식
        - 프로세스 크기에 상관없이 메모리가 같은 크기로 나뉨
        - 큰 프로세스가 메모리에 올라오면 여러 조각으로 나누어 배치
        - 비연속 메모리 할당
        - 장점 : 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리 수월 (메모리 통합 같은 부가적인 작업 필요 x)
        - 단점 : 쓸모없는 공간으로 인해 메모리 낭비 발생 가능

<br/>

#### 단편화(조각화) : 빈 영역이 있어도 서로 떨어져 있으면 프로세스를 배정하지 못함. 이로 인해 작은 조각들이 발생하는 현상

## 가변 분할 방식의 메모리 관리
  - 외부 단편화 : 빈 공간보다 큰 프로세스가 들어와 메모리를 배정하지 못해 공간이 남는 현상
      
  - 외부 단편화 해결
      - 메모리 배치 방식 : 작은 조각들이 발생하지 않도록 프로세스 배치
      - 조각 모음 : 조각이 발생했을 때 작은 조각들을 모아서 큰 조각으로 만드는 작업
      
  - 메모리 배치 방식
      - 최초 배치
          - 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법
          - 장점 : 빈 공간을 찾아다닐 필요 없음
      - 최적 배치
          - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스 배치
          - 빈 공간을 모두 확인하는 부가적인 작업이 있지만 딱 맞는 공간을 찾을 경우 단편화가 일어나지 않음
          - 딱 맞는 공간이 없을 때 아주 작은 조각 발생
      - 최악 배치
          - 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스 배치
          - 빈 공간 크기가 클 때는 효율적. 빈 공간의 크기가 점점 줄어들면 최적 배치처럼 작은 조각 발생
  - 조각 모음(defragmentation)
      - 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만드는 작업
      - “프로세스 중지 → 프로세스 이동 → 프로세스 재시작”의 과정이 필요하여 오버헤드 발생 가능
      
<br/>

## 고정 분할 방식의 메모리 관리
  - 내부 단편화 : 각 메모리 조각에 프로세스를 배치하고 공간이 남는 현상
  - 적절한 메모리 크기 결정이 중요

---

## 페이징(Paging) - 고정 분할 방식
  - 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
  - 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법 ⇒ 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론
  - 물리 메모리는 **frame**이라는 고정 크기로 분리, 논리 메모리(프로세스가 점유하는)는 **페이지**라 불리는 고정 크기의 블록으로 분리
  - 페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점 존재
  - 하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있음
  - 단점
      - 내부 단편화 문제

  - 페이지 테이블 (page table)
      - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
      - 가상 주소(Virtual Address) v = (p, d)
      - p : 가상 메모리 페이지, d : p 안에서 참조하는 위치
      - 가상 주소를 가지고 어떤 데이터에 접근하고자 하면,
          1. page table에 해당 가상 주소와 그 page 번호(p)가 있는지 확인
          2. page 번호가 있으면 이와 매핑된 **첫** 물리 주소(p') 찾기
          3. 페이지 처음부터 얼마 떨어진 위치인지를 알려주는 변위(d)를 더하면
          4. p' + d 가 실제 물리 주소
          
<br/>


## 세그멘테이션(Segmentation) - 가변 분할 방식
  - 페이징처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, **서로 다른 크기**의 **논리적 단위**인 **세그먼트(Segment)**로 분할.
  - 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위)
  - 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
  - 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있음 (외부 단편화)
    
<br/>

## 페이징 기법과 세그멘테이션 기법 비교
- 페이징 기법 → 각 구조의 논리적 역할과 상관없이 일률적으로 같은 크기의 페이지로 쪼개 물리 메모리에 올림
- 세그멘테이션 기법 → 서로 크기가 다른, 논리적 단위인 세그먼트를 물리 메모리에 올림
